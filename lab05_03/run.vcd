$date
	Thu May 27 16:17:40 2021
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module test_instruction_decoder $end
$var wire 32 ! rs2_data [31:0] $end
$var wire 32 " rs1_data [31:0] $end
$var wire 5 # rd_address [4:0] $end
$var wire 2 $ mem_to_regs_option [1:0] $end
$var wire 1 % is_write_regs_future $end
$var wire 1 & is_write_mem_future $end
$var wire 32 ' immediate [31:0] $end
$var wire 3 ( branch_type [2:0] $end
$var wire 3 ) ALU_option [2:0] $end
$var wire 1 * ALU_B_option $end
$var reg 1 + clk $end
$var reg 32 , instruction [31:0] $end
$var reg 1 - rst $end
$scope module instruction_decoder $end
$var wire 1 + clk $end
$var wire 1 . cpu_en $end
$var wire 32 / instruction [31:0] $end
$var wire 1 0 is_write_regs $end
$var wire 1 - rst $end
$var wire 5 1 write_regs_address [4:0] $end
$var wire 32 2 write_regs_data [31:0] $end
$var wire 32 3 rs2_data [31:0] $end
$var wire 5 4 rs2_address [4:0] $end
$var wire 32 5 rs1_data [31:0] $end
$var wire 5 6 rs1_address [4:0] $end
$var wire 5 7 rd_address [4:0] $end
$var wire 7 8 opcode [6:0] $end
$var wire 2 9 mem_to_regs_option [1:0] $end
$var wire 1 % is_write_regs_future $end
$var wire 1 & is_write_mem_future $end
$var wire 3 : instruction_type [2:0] $end
$var wire 32 ; immediate [31:0] $end
$var wire 3 < funct3 [2:0] $end
$var wire 3 = branch_type [2:0] $end
$var wire 3 > ALU_option [2:0] $end
$var wire 1 * ALU_B_option $end
$scope module controller $end
$var wire 3 ? funct3 [2:0] $end
$var wire 1 @ funct7 $end
$var wire 7 A opcode [6:0] $end
$var reg 1 * ALU_B_option $end
$var reg 3 B ALU_option [2:0] $end
$var reg 3 C branch_type [2:0] $end
$var reg 3 D instruction_type [2:0] $end
$var reg 1 & is_write_mem_future $end
$var reg 1 % is_write_regs_future $end
$var reg 2 E mem_to_regs_option [1:0] $end
$upscope $end
$scope module immediate_generator $end
$var wire 32 F instruction [31:0] $end
$var wire 3 G instruction_type [2:0] $end
$var reg 32 H immediate [31:0] $end
$upscope $end
$scope module registers $end
$var wire 1 + clk $end
$var wire 1 . cpu_en $end
$var wire 1 0 is_write_regs $end
$var wire 5 I rs1_address [4:0] $end
$var wire 5 J rs2_address [4:0] $end
$var wire 1 - rst $end
$var wire 5 K write_address [4:0] $end
$var wire 32 L write_data [31:0] $end
$var wire 32 M rs2_data [31:0] $end
$var wire 32 N rs1_data [31:0] $end
$var integer 32 O i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b100000 O
b0 N
b0 M
b0 L
b0 K
b0 J
b0 I
bx H
bx G
b0 F
bx E
bx D
bx C
bx B
b0 A
0@
b0 ?
bx >
bx =
b0 <
bx ;
bx :
bx 9
b0 8
b0 7
b0 6
b0 5
b0 4
b0 3
b0 2
b0 1
00
b0 /
1.
0-
b0 ,
0+
x*
bx )
bx (
bx '
x&
x%
bx $
b0 #
b0 "
b0 !
$end
#20
1+
b0 )
b0 >
b0 B
b0 $
b0 9
b0 E
1%
0&
b0 (
b0 =
b0 C
0*
b0 :
b0 D
b0 G
b1 #
b1 7
b1 6
b1 I
b110011 8
b110011 A
b1000000010110011 ,
b1000000010110011 /
b1000000010110011 F
#40
0+
#60
1+
b1111101000000000000000 '
b1111101000000000000000 ;
b1111101000000000000000 H
b100 :
b100 D
b100 G
b11 $
b11 9
b11 E
b10 #
b10 7
b11101 6
b11101 I
b11 4
b11 J
b110111 8
b110111 A
b1111101000000100110111 ,
b1111101000000100110111 /
b1111101000000100110111 F
#80
0+
#100
1+
b11 (
b11 =
b11 C
b101 :
b101 D
b101 G
b10 $
b10 9
b10 E
b11 #
b11 7
b0 6
b0 I
b1000 4
b1000 J
b1101111 8
b1101111 A
b1111101000 '
b1111101000 ;
b1111101000 H
b111110100000000000000111101111 ,
b111110100000000000000111101111 /
b111110100000000000000111101111 F
#120
0+
#140
1+
1*
b100 (
b100 =
b100 C
b110 :
b110 D
b110 G
b101 #
b101 7
b100 6
b100 I
b100 4
b100 J
b1100111 8
b1100111 A
b110010000100000000000000000 '
b110010000100000000000000000 ;
b110010000100000000000000000 H
b110010000100000001011100111 ,
b110010000100000001011100111 /
b110010000100000001011100111 F
#160
0+
#180
1+
b0 (
b0 =
b0 C
b1 :
b1 D
b1 G
b0 $
b0 9
b0 E
b100 #
b100 7
b11110 4
b11110 J
b10011 8
b10011 A
b11110 '
b11110 ;
b11110 H
b1111000100000001000010011 ,
b1111000100000001000010011 /
b1111000100000001000010011 F
#200
0+
#220
1+
b0 #
b0 7
b0 6
b0 I
b0 4
b0 J
b0 '
b0 ;
b0 H
b10011 ,
b10011 /
b10011 F
#240
0+
#260
1+
#280
0+
#300
1+
#320
0+
